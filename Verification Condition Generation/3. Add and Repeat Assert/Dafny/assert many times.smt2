(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :auto_config false)
(set-option :type_check true)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.delay_units true)
(set-option :smt.case_split 3)
(set-option :smt.arith.solver 2)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(set-info :category "industrial")
(declare-sort |T@U| 0)
(declare-sort |T@T| 0)
(declare-fun real_pow (Real Real) Real)
(declare-fun UOrdering2 (|T@U| |T@U|) Bool)
(declare-fun UOrdering3 (|T@T| |T@U| |T@U|) Bool)
(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-fun TBool () T@U)
(declare-fun TChar () T@U)
(declare-fun TInt () T@U)
(declare-fun TReal () T@U)
(declare-fun TORDINAL () T@U)
(declare-fun TagBool () T@U)
(declare-fun TagChar () T@U)
(declare-fun TagInt () T@U)
(declare-fun TagReal () T@U)
(declare-fun TagORDINAL () T@U)
(declare-fun TagSet () T@U)
(declare-fun TagISet () T@U)
(declare-fun TagMultiSet () T@U)
(declare-fun TagSeq () T@U)
(declare-fun TagMap () T@U)
(declare-fun TagIMap () T@U)
(declare-fun alloc () T@U)
(declare-fun Ctor (T@T) Int)
(declare-fun boolType () T@T)
(declare-fun intType () T@T)
(declare-fun realType () T@T)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun type (T@U) T@T)
(declare-fun int_2_U (Int) T@U)
(declare-fun U_2_int (T@U) Int)
(declare-fun real_2_U (Real) T@U)
(declare-fun U_2_real (T@U) Real)
(declare-fun TyType () T@T)
(declare-fun TyTagType () T@T)
(declare-fun FieldType (T@T) T@T)
(declare-fun FieldTypeInv0 (T@T) T@T)
(declare-fun Tag (T@U) T@U)
(declare-fun $IsAlloc (T@U T@U T@U) Bool)
(declare-fun TBitvector (Int) T@U)
(declare-fun MapType0Type (T@T T@T) T@T)
(declare-fun refType () T@T)
(declare-fun MapType1Type () T@T)
(declare-fun MapType0TypeInv0 (T@T) T@T)
(declare-fun MapType0TypeInv1 (T@T) T@T)
(declare-fun MapType0Select (T@U T@U) T@U)
(declare-fun MapType0Store (T@U T@U T@U) T@U)
(declare-fun MapType1Select (T@U T@U) T@U)
(declare-fun MapType1Store (T@U T@U T@U) T@U)
(declare-fun MapType2Select (T@U T@U T@U) T@U)
(declare-fun |lambda#0| (T@U T@U T@U Bool) T@U)
(declare-fun MapType2Type (T@T T@T) T@T)
(declare-fun MapType2TypeInv0 (T@T) T@T)
(declare-fun MapType2TypeInv1 (T@T) T@T)
(declare-fun MapType2Store (T@U T@U T@U T@U) T@U)
(declare-fun LitInt (Int) Int)
(declare-fun Lit (T@U) T@U)
(declare-fun $FunctionContextHeight () Int)
(declare-fun _module.__default.add (Int Int) Int)
(declare-fun |_module.__default.add#canCall| (Int Int) Bool)
(declare-fun |Seq#Empty| (T@T) T@U)
(declare-fun |Seq#Length| (T@U) Int)
(declare-fun SeqType (T@T) T@T)
(declare-fun SeqTypeInv0 (T@T) T@T)
(declare-fun $IsAllocBox (T@U T@U T@U) Bool)
(declare-fun $Box (T@U) T@U)
(declare-fun BoxType () T@T)
(declare-fun |Map#Domain| (T@U) T@U)
(declare-fun |Map#Empty| (T@T T@T) T@U)
(declare-fun MapType (T@T T@T) T@T)
(declare-fun MapTypeInv0 (T@T) T@T)
(declare-fun MapTypeInv1 (T@T) T@T)
(declare-fun |IMap#Domain| (T@U) T@U)
(declare-fun |IMap#Empty| (T@T T@T) T@U)
(declare-fun IMapType (T@T T@T) T@T)
(declare-fun IMapTypeInv0 (T@T) T@T)
(declare-fun IMapTypeInv1 (T@T) T@T)
(declare-fun TSet (T@U) T@U)
(declare-fun TISet (T@U) T@U)
(declare-fun TMap (T@U T@U) T@U)
(declare-fun |Map#Elements| (T@U) T@U)
(declare-fun TIMap (T@U T@U) T@U)
(declare-fun |IMap#Elements| (T@U) T@U)
(declare-fun |ISet#Empty| (T@T) T@U)
(declare-fun Inv0_TMap (T@U) T@U)
(declare-fun Inv1_TMap (T@U) T@U)
(declare-fun Inv0_TIMap (T@U) T@U)
(declare-fun Inv1_TIMap (T@U) T@U)
(declare-fun TSeq (T@U) T@U)
(declare-fun |Seq#Index| (T@U Int) T@U)
(declare-fun Inv0_TBitvector (T@U) Int)
(declare-fun Inv0_TSet (T@U) T@U)
(declare-fun Inv0_TISet (T@U) T@U)
(declare-fun TMultiSet (T@U) T@U)
(declare-fun Inv0_TMultiSet (T@U) T@U)
(declare-fun Inv0_TSeq (T@U) T@U)
(declare-fun $Unbox (T@T T@U) T@U)
(declare-fun charType () T@T)
(assert  (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (Ctor boolType) 0) (= (Ctor intType) 1)) (= (Ctor realType) 2)) (forall ((arg0 Bool) ) (! (= (U_2_bool (bool_2_U arg0)) arg0)
 :pattern ( (bool_2_U arg0))
))) (forall ((x T@U) ) (!  (=> (= (type x) boolType) (= (bool_2_U (U_2_bool x)) x))
 :pattern ( (U_2_bool x))
))) (forall ((arg0@@0 Bool) ) (! (= (type (bool_2_U arg0@@0)) boolType)
 :pattern ( (bool_2_U arg0@@0))
))) (forall ((arg0@@1 Int) ) (! (= (U_2_int (int_2_U arg0@@1)) arg0@@1)
 :pattern ( (int_2_U arg0@@1))
))) (forall ((x@@0 T@U) ) (!  (=> (= (type x@@0) intType) (= (int_2_U (U_2_int x@@0)) x@@0))
 :pattern ( (U_2_int x@@0))
))) (forall ((arg0@@2 Int) ) (! (= (type (int_2_U arg0@@2)) intType)
 :pattern ( (int_2_U arg0@@2))
))) (forall ((arg0@@3 Real) ) (! (= (U_2_real (real_2_U arg0@@3)) arg0@@3)
 :pattern ( (real_2_U arg0@@3))
))) (forall ((x@@1 T@U) ) (!  (=> (= (type x@@1) realType) (= (real_2_U (U_2_real x@@1)) x@@1))
 :pattern ( (U_2_real x@@1))
))) (forall ((arg0@@4 Real) ) (! (= (type (real_2_U arg0@@4)) realType)
 :pattern ( (real_2_U arg0@@4))
))) (= (Ctor TyType) 3)) (= (type TBool) TyType)) (= (type TChar) TyType)) (= (type TInt) TyType)) (= (type TReal) TyType)) (= (type TORDINAL) TyType)) (= (Ctor TyTagType) 4)) (= (type TagBool) TyTagType)) (= (type TagChar) TyTagType)) (= (type TagInt) TyTagType)) (= (type TagReal) TyTagType)) (= (type TagORDINAL) TyTagType)) (= (type TagSet) TyTagType)) (= (type TagISet) TyTagType)) (= (type TagMultiSet) TyTagType)) (= (type TagSeq) TyTagType)) (= (type TagMap) TyTagType)) (= (type TagIMap) TyTagType)) (forall ((arg0@@5 T@T) ) (= (Ctor (FieldType arg0@@5)) 5))) (forall ((arg0@@6 T@T) ) (! (= (FieldTypeInv0 (FieldType arg0@@6)) arg0@@6)
 :pattern ( (FieldType arg0@@6))
))) (= (type alloc) (FieldType boolType))))
(assert (distinct TBool TChar TInt TReal TORDINAL TagBool TagChar TagInt TagReal TagORDINAL TagSet TagISet TagMultiSet TagSeq TagMap TagIMap alloc)
)
(assert (forall ((arg0@@7 T@U) ) (! (= (type (Tag arg0@@7)) TyTagType)
 :pattern ( (Tag arg0@@7))
)))
(assert (= (Tag TBool) TagBool))
(assert (= (Tag TChar) TagChar))
(assert (= (Tag TInt) TagInt))
(assert (= (Tag TReal) TagReal))
(assert (= (Tag TORDINAL) TagORDINAL))
(assert  (and (and (and (and (and (and (and (and (and (and (and (and (and (forall ((arg0@@8 T@T) (arg1 T@T) ) (= (Ctor (MapType0Type arg0@@8 arg1)) 6)) (forall ((arg0@@9 T@T) (arg1@@0 T@T) ) (! (= (MapType0TypeInv0 (MapType0Type arg0@@9 arg1@@0)) arg0@@9)
 :pattern ( (MapType0Type arg0@@9 arg1@@0))
))) (forall ((arg0@@10 T@T) (arg1@@1 T@T) ) (! (= (MapType0TypeInv1 (MapType0Type arg0@@10 arg1@@1)) arg1@@1)
 :pattern ( (MapType0Type arg0@@10 arg1@@1))
))) (forall ((arg0@@11 T@U) (arg1@@2 T@U) ) (! (let ((aVar1 (MapType0TypeInv1 (type arg0@@11))))
(= (type (MapType0Select arg0@@11 arg1@@2)) aVar1))
 :pattern ( (MapType0Select arg0@@11 arg1@@2))
))) (forall ((arg0@@12 T@U) (arg1@@3 T@U) (arg2 T@U) ) (! (let ((aVar1@@0 (type arg2)))
(let ((aVar0 (type arg1@@3)))
(= (type (MapType0Store arg0@@12 arg1@@3 arg2)) (MapType0Type aVar0 aVar1@@0))))
 :pattern ( (MapType0Store arg0@@12 arg1@@3 arg2))
))) (forall ((m T@U) (x0 T@U) (val T@U) ) (! (let ((aVar1@@1 (MapType0TypeInv1 (type m))))
 (=> (= (type val) aVar1@@1) (= (MapType0Select (MapType0Store m x0 val) x0) val)))
 :weight 0
))) (and (forall ((val@@0 T@U) (m@@0 T@U) (x0@@0 T@U) (y0 T@U) ) (!  (or (= x0@@0 y0) (= (MapType0Select (MapType0Store m@@0 x0@@0 val@@0) y0) (MapType0Select m@@0 y0)))
 :weight 0
)) (forall ((val@@1 T@U) (m@@1 T@U) (x0@@1 T@U) (y0@@0 T@U) ) (!  (or true (= (MapType0Select (MapType0Store m@@1 x0@@1 val@@1) y0@@0) (MapType0Select m@@1 y0@@0)))
 :weight 0
)))) (= (Ctor refType) 7)) (forall ((arg0@@13 T@U) (arg1@@4 T@U) ) (! (let ((alpha (FieldTypeInv0 (type arg1@@4))))
(= (type (MapType1Select arg0@@13 arg1@@4)) alpha))
 :pattern ( (MapType1Select arg0@@13 arg1@@4))
))) (= (Ctor MapType1Type) 8)) (forall ((arg0@@14 T@U) (arg1@@5 T@U) (arg2@@0 T@U) ) (! (= (type (MapType1Store arg0@@14 arg1@@5 arg2@@0)) MapType1Type)
 :pattern ( (MapType1Store arg0@@14 arg1@@5 arg2@@0))
))) (forall ((m@@2 T@U) (x0@@2 T@U) (val@@2 T@U) ) (! (let ((alpha@@0 (FieldTypeInv0 (type x0@@2))))
 (=> (= (type val@@2) alpha@@0) (= (MapType1Select (MapType1Store m@@2 x0@@2 val@@2) x0@@2) val@@2)))
 :weight 0
))) (and (forall ((val@@3 T@U) (m@@3 T@U) (x0@@3 T@U) (y0@@1 T@U) ) (!  (or (= x0@@3 y0@@1) (= (MapType1Select (MapType1Store m@@3 x0@@3 val@@3) y0@@1) (MapType1Select m@@3 y0@@1)))
 :weight 0
)) (forall ((val@@4 T@U) (m@@4 T@U) (x0@@4 T@U) (y0@@2 T@U) ) (!  (or true (= (MapType1Select (MapType1Store m@@4 x0@@4 val@@4) y0@@2) (MapType1Select m@@4 y0@@2)))
 :weight 0
)))) (forall ((arg0@@15 Int) ) (! (= (type (TBitvector arg0@@15)) TyType)
 :pattern ( (TBitvector arg0@@15))
))))
(assert (forall ((v T@U) (h T@U) ) (!  (=> (and (= (type v) intType) (= (type h) (MapType0Type refType MapType1Type))) ($IsAlloc v (TBitvector 0) h))
 :pattern ( ($IsAlloc v (TBitvector 0) h))
)))
(assert  (and (and (and (and (and (and (and (forall ((arg0@@16 T@T) (arg1@@6 T@T) ) (= (Ctor (MapType2Type arg0@@16 arg1@@6)) 9)) (forall ((arg0@@17 T@T) (arg1@@7 T@T) ) (! (= (MapType2TypeInv0 (MapType2Type arg0@@17 arg1@@7)) arg0@@17)
 :pattern ( (MapType2Type arg0@@17 arg1@@7))
))) (forall ((arg0@@18 T@T) (arg1@@8 T@T) ) (! (= (MapType2TypeInv1 (MapType2Type arg0@@18 arg1@@8)) arg1@@8)
 :pattern ( (MapType2Type arg0@@18 arg1@@8))
))) (forall ((arg0@@19 T@U) (arg1@@9 T@U) (arg2@@1 T@U) ) (! (let ((aVar1@@2 (MapType2TypeInv1 (type arg0@@19))))
(= (type (MapType2Select arg0@@19 arg1@@9 arg2@@1)) aVar1@@2))
 :pattern ( (MapType2Select arg0@@19 arg1@@9 arg2@@1))
))) (forall ((arg0@@20 T@U) (arg1@@10 T@U) (arg2@@2 T@U) (arg3 T@U) ) (! (let ((aVar1@@3 (type arg3)))
(let ((aVar0@@0 (type arg1@@10)))
(= (type (MapType2Store arg0@@20 arg1@@10 arg2@@2 arg3)) (MapType2Type aVar0@@0 aVar1@@3))))
 :pattern ( (MapType2Store arg0@@20 arg1@@10 arg2@@2 arg3))
))) (forall ((m@@5 T@U) (x0@@5 T@U) (x1 T@U) (val@@5 T@U) ) (! (let ((aVar1@@4 (MapType2TypeInv1 (type m@@5))))
 (=> (= (type val@@5) aVar1@@4) (= (MapType2Select (MapType2Store m@@5 x0@@5 x1 val@@5) x0@@5 x1) val@@5)))
 :weight 0
))) (and (and (forall ((val@@6 T@U) (m@@6 T@U) (x0@@6 T@U) (x1@@0 T@U) (y0@@3 T@U) (y1 T@U) ) (!  (or (= x0@@6 y0@@3) (= (MapType2Select (MapType2Store m@@6 x0@@6 x1@@0 val@@6) y0@@3 y1) (MapType2Select m@@6 y0@@3 y1)))
 :weight 0
)) (forall ((val@@7 T@U) (m@@7 T@U) (x0@@7 T@U) (x1@@1 T@U) (y0@@4 T@U) (y1@@0 T@U) ) (!  (or (= x1@@1 y1@@0) (= (MapType2Select (MapType2Store m@@7 x0@@7 x1@@1 val@@7) y0@@4 y1@@0) (MapType2Select m@@7 y0@@4 y1@@0)))
 :weight 0
))) (forall ((val@@8 T@U) (m@@8 T@U) (x0@@8 T@U) (x1@@2 T@U) (y0@@5 T@U) (y1@@1 T@U) ) (!  (or true (= (MapType2Select (MapType2Store m@@8 x0@@8 x1@@2 val@@8) y0@@5 y1@@1) (MapType2Select m@@8 y0@@5 y1@@1)))
 :weight 0
)))) (forall ((arg0@@21 T@U) (arg1@@11 T@U) (arg2@@3 T@U) (arg3@@0 Bool) ) (! (= (type (|lambda#0| arg0@@21 arg1@@11 arg2@@3 arg3@@0)) (MapType2Type refType boolType))
 :pattern ( (|lambda#0| arg0@@21 arg1@@11 arg2@@3 arg3@@0))
))))
(assert (forall ((|l#0| T@U) (|l#1| T@U) (|l#2| T@U) (|l#3| Bool) ($o T@U) ($f T@U) ) (! (let ((alpha@@1 (FieldTypeInv0 (type $f))))
 (=> (and (and (and (and (= (type |l#0|) refType) (= (type |l#1|) (MapType0Type refType MapType1Type))) (= (type |l#2|) (FieldType boolType))) (= (type $o) refType)) (= (type $f) (FieldType alpha@@1))) (= (U_2_bool (MapType2Select (|lambda#0| |l#0| |l#1| |l#2| |l#3|) $o $f))  (=> (and (not (= $o |l#0|)) (U_2_bool (MapType1Select (MapType0Select |l#1| $o) |l#2|))) |l#3|))))
 :pattern ( (MapType2Select (|lambda#0| |l#0| |l#1| |l#2| |l#3|) $o $f))
)))
(assert (forall ((x@@2 Int) ) (! (= (LitInt x@@2) x@@2)
 :pattern ( (LitInt x@@2))
)))
(assert (forall ((arg0@@22 T@U) ) (! (let ((T (type arg0@@22)))
(= (type (Lit arg0@@22)) T))
 :pattern ( (Lit arg0@@22))
)))
(assert (forall ((x@@3 T@U) ) (! (= (Lit x@@3) x@@3)
 :pattern ( (Lit x@@3))
)))
(assert  (=> (<= 0 $FunctionContextHeight) (forall ((|a#0| Int) (|b#0| Int) ) (!  (=> (or (|_module.__default.add#canCall| (LitInt |a#0|) (LitInt |b#0|)) (< 0 $FunctionContextHeight)) (= (_module.__default.add (LitInt |a#0|) (LitInt |b#0|)) (LitInt (+ |a#0| |b#0|))))
 :weight 3
 :pattern ( (_module.__default.add (LitInt |a#0|) (LitInt |b#0|)))
))))
(assert  (=> (<= 0 $FunctionContextHeight) (forall ((|a#0@@0| Int) (|b#0@@0| Int) ) (!  (=> (or (|_module.__default.add#canCall| |a#0@@0| |b#0@@0|) (< 0 $FunctionContextHeight)) true)
 :pattern ( (_module.__default.add |a#0@@0| |b#0@@0|))
))))
(assert  (and (and (forall ((arg0@@23 T@T) ) (= (Ctor (SeqType arg0@@23)) 10)) (forall ((arg0@@24 T@T) ) (! (= (SeqTypeInv0 (SeqType arg0@@24)) arg0@@24)
 :pattern ( (SeqType arg0@@24))
))) (forall ((T@@0 T@T) ) (! (= (type (|Seq#Empty| T@@0)) (SeqType T@@0))
 :pattern ( (|Seq#Empty| T@@0))
))))
(assert (forall ((T@@1 T@T) ) (! (= (|Seq#Length| (|Seq#Empty| T@@1)) 0)
 :pattern ( (|Seq#Empty| T@@1))
)))
(assert  (and (= (Ctor BoxType) 11) (forall ((arg0@@25 T@U) ) (! (= (type ($Box arg0@@25)) BoxType)
 :pattern ( ($Box arg0@@25))
))))
(assert (forall ((v@@0 T@U) (t T@U) (h@@0 T@U) ) (!  (=> (and (= (type t) TyType) (= (type h@@0) (MapType0Type refType MapType1Type))) (= ($IsAllocBox ($Box v@@0) t h@@0) ($IsAlloc v@@0 t h@@0)))
 :pattern ( ($IsAllocBox ($Box v@@0) t h@@0))
)))
(assert  (and (and (and (and (forall ((arg0@@26 T@T) (arg1@@12 T@T) ) (= (Ctor (MapType arg0@@26 arg1@@12)) 12)) (forall ((arg0@@27 T@T) (arg1@@13 T@T) ) (! (= (MapTypeInv0 (MapType arg0@@27 arg1@@13)) arg0@@27)
 :pattern ( (MapType arg0@@27 arg1@@13))
))) (forall ((arg0@@28 T@T) (arg1@@14 T@T) ) (! (= (MapTypeInv1 (MapType arg0@@28 arg1@@14)) arg1@@14)
 :pattern ( (MapType arg0@@28 arg1@@14))
))) (forall ((arg0@@29 T@U) ) (! (let ((U (MapTypeInv0 (type arg0@@29))))
(= (type (|Map#Domain| arg0@@29)) (MapType0Type U boolType)))
 :pattern ( (|Map#Domain| arg0@@29))
))) (forall ((U@@0 T@T) (V T@T) ) (! (= (type (|Map#Empty| U@@0 V)) (MapType U@@0 V))
 :pattern ( (|Map#Empty| U@@0 V))
))))
(assert (forall ((u T@U) (V@@0 T@T) ) (! (let ((U@@1 (type u)))
 (not (U_2_bool (MapType0Select (|Map#Domain| (|Map#Empty| U@@1 V@@0)) u))))
 :pattern ( (let ((U@@1 (type u)))
(MapType0Select (|Map#Domain| (|Map#Empty| U@@1 V@@0)) u)))
)))
(assert  (and (and (and (and (forall ((arg0@@30 T@T) (arg1@@15 T@T) ) (= (Ctor (IMapType arg0@@30 arg1@@15)) 13)) (forall ((arg0@@31 T@T) (arg1@@16 T@T) ) (! (= (IMapTypeInv0 (IMapType arg0@@31 arg1@@16)) arg0@@31)
 :pattern ( (IMapType arg0@@31 arg1@@16))
))) (forall ((arg0@@32 T@T) (arg1@@17 T@T) ) (! (= (IMapTypeInv1 (IMapType arg0@@32 arg1@@17)) arg1@@17)
 :pattern ( (IMapType arg0@@32 arg1@@17))
))) (forall ((arg0@@33 T@U) ) (! (let ((U@@2 (IMapTypeInv0 (type arg0@@33))))
(= (type (|IMap#Domain| arg0@@33)) (MapType0Type U@@2 boolType)))
 :pattern ( (|IMap#Domain| arg0@@33))
))) (forall ((U@@3 T@T) (V@@1 T@T) ) (! (= (type (|IMap#Empty| U@@3 V@@1)) (IMapType U@@3 V@@1))
 :pattern ( (|IMap#Empty| U@@3 V@@1))
))))
(assert (forall ((u@@0 T@U) (V@@2 T@T) ) (! (let ((U@@4 (type u@@0)))
 (not (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Empty| U@@4 V@@2)) u@@0))))
 :pattern ( (let ((U@@4 (type u@@0)))
(MapType0Select (|IMap#Domain| (|IMap#Empty| U@@4 V@@2)) u@@0)))
)))
(assert (forall ((m@@9 T@U) ) (! (let ((V@@3 (MapTypeInv1 (type m@@9))))
(let ((U@@5 (MapTypeInv0 (type m@@9))))
 (=> (= (type m@@9) (MapType U@@5 V@@3)) (or (= m@@9 (|Map#Empty| U@@5 V@@3)) (exists ((k T@U) ) (!  (and (= (type k) U@@5) (U_2_bool (MapType0Select (|Map#Domain| m@@9) k)))
 :no-pattern (type k)
 :no-pattern (U_2_int k)
 :no-pattern (U_2_bool k)
))))))
 :pattern ( (|Map#Domain| m@@9))
)))
(assert (forall ((m@@10 T@U) ) (! (let ((V@@4 (IMapTypeInv1 (type m@@10))))
(let ((U@@6 (IMapTypeInv0 (type m@@10))))
 (=> (= (type m@@10) (IMapType U@@6 V@@4)) (or (= m@@10 (|IMap#Empty| U@@6 V@@4)) (exists ((k@@0 T@U) ) (!  (and (= (type k@@0) U@@6) (U_2_bool (MapType0Select (|IMap#Domain| m@@10) k@@0)))
 :no-pattern (type k@@0)
 :no-pattern (U_2_int k@@0)
 :no-pattern (U_2_bool k@@0)
))))))
 :pattern ( (|IMap#Domain| m@@10))
)))
(assert (forall ((arg0@@34 T@U) ) (! (= (type (TSet arg0@@34)) TyType)
 :pattern ( (TSet arg0@@34))
)))
(assert (forall ((v@@1 T@U) (t0 T@U) (h@@1 T@U) ) (!  (=> (and (and (= (type v@@1) (MapType0Type BoxType boolType)) (= (type t0) TyType)) (= (type h@@1) (MapType0Type refType MapType1Type))) (= ($IsAlloc v@@1 (TSet t0) h@@1) (forall ((bx T@U) ) (!  (=> (and (= (type bx) BoxType) (U_2_bool (MapType0Select v@@1 bx))) ($IsAllocBox bx t0 h@@1))
 :pattern ( (MapType0Select v@@1 bx))
))))
 :pattern ( ($IsAlloc v@@1 (TSet t0) h@@1))
)))
(assert (forall ((arg0@@35 T@U) ) (! (= (type (TISet arg0@@35)) TyType)
 :pattern ( (TISet arg0@@35))
)))
(assert (forall ((v@@2 T@U) (t0@@0 T@U) (h@@2 T@U) ) (!  (=> (and (and (= (type v@@2) (MapType0Type BoxType boolType)) (= (type t0@@0) TyType)) (= (type h@@2) (MapType0Type refType MapType1Type))) (= ($IsAlloc v@@2 (TISet t0@@0) h@@2) (forall ((bx@@0 T@U) ) (!  (=> (and (= (type bx@@0) BoxType) (U_2_bool (MapType0Select v@@2 bx@@0))) ($IsAllocBox bx@@0 t0@@0 h@@2))
 :pattern ( (MapType0Select v@@2 bx@@0))
))))
 :pattern ( ($IsAlloc v@@2 (TISet t0@@0) h@@2))
)))
(assert  (and (forall ((arg0@@36 T@U) (arg1@@18 T@U) ) (! (= (type (TMap arg0@@36 arg1@@18)) TyType)
 :pattern ( (TMap arg0@@36 arg1@@18))
)) (forall ((arg0@@37 T@U) ) (! (let ((V@@5 (MapTypeInv1 (type arg0@@37))))
(let ((U@@7 (MapTypeInv0 (type arg0@@37))))
(= (type (|Map#Elements| arg0@@37)) (MapType0Type U@@7 V@@5))))
 :pattern ( (|Map#Elements| arg0@@37))
))))
(assert (forall ((v@@3 T@U) (t0@@1 T@U) (t1 T@U) (h@@3 T@U) ) (!  (=> (and (and (and (= (type v@@3) (MapType BoxType BoxType)) (= (type t0@@1) TyType)) (= (type t1) TyType)) (= (type h@@3) (MapType0Type refType MapType1Type))) (= ($IsAlloc v@@3 (TMap t0@@1 t1) h@@3) (forall ((bx@@1 T@U) ) (!  (=> (and (= (type bx@@1) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@3) bx@@1))) (and ($IsAllocBox (MapType0Select (|Map#Elements| v@@3) bx@@1) t1 h@@3) ($IsAllocBox bx@@1 t0@@1 h@@3)))
 :pattern ( (MapType0Select (|Map#Elements| v@@3) bx@@1))
 :pattern ( (MapType0Select (|Map#Domain| v@@3) bx@@1))
))))
 :pattern ( ($IsAlloc v@@3 (TMap t0@@1 t1) h@@3))
)))
(assert  (and (forall ((arg0@@38 T@U) (arg1@@19 T@U) ) (! (= (type (TIMap arg0@@38 arg1@@19)) TyType)
 :pattern ( (TIMap arg0@@38 arg1@@19))
)) (forall ((arg0@@39 T@U) ) (! (let ((V@@6 (IMapTypeInv1 (type arg0@@39))))
(let ((U@@8 (IMapTypeInv0 (type arg0@@39))))
(= (type (|IMap#Elements| arg0@@39)) (MapType0Type U@@8 V@@6))))
 :pattern ( (|IMap#Elements| arg0@@39))
))))
(assert (forall ((v@@4 T@U) (t0@@2 T@U) (t1@@0 T@U) (h@@4 T@U) ) (!  (=> (and (and (and (= (type v@@4) (IMapType BoxType BoxType)) (= (type t0@@2) TyType)) (= (type t1@@0) TyType)) (= (type h@@4) (MapType0Type refType MapType1Type))) (= ($IsAlloc v@@4 (TIMap t0@@2 t1@@0) h@@4) (forall ((bx@@2 T@U) ) (!  (=> (and (= (type bx@@2) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@4) bx@@2))) (and ($IsAllocBox (MapType0Select (|IMap#Elements| v@@4) bx@@2) t1@@0 h@@4) ($IsAllocBox bx@@2 t0@@2 h@@4)))
 :pattern ( (MapType0Select (|IMap#Elements| v@@4) bx@@2))
 :pattern ( (MapType0Select (|IMap#Domain| v@@4) bx@@2))
))))
 :pattern ( ($IsAlloc v@@4 (TIMap t0@@2 t1@@0) h@@4))
)))
(assert  (=> (<= 0 $FunctionContextHeight) (forall ((|a#0@@1| Int) (|b#0@@1| Int) ) (!  (=> (or (|_module.__default.add#canCall| |a#0@@1| |b#0@@1|) (< 0 $FunctionContextHeight)) (= (_module.__default.add |a#0@@1| |b#0@@1|) (+ |a#0@@1| |b#0@@1|)))
 :pattern ( (_module.__default.add |a#0@@1| |b#0@@1|))
))))
(assert (forall ((T@@2 T@T) ) (! (= (type (|ISet#Empty| T@@2)) (MapType0Type T@@2 boolType))
 :pattern ( (|ISet#Empty| T@@2))
)))
(assert (forall ((m@@11 T@U) ) (! (let ((V@@7 (IMapTypeInv1 (type m@@11))))
(let ((U@@9 (IMapTypeInv0 (type m@@11))))
 (=> (= (type m@@11) (IMapType U@@9 V@@7)) (= (= m@@11 (|IMap#Empty| U@@9 V@@7)) (= (|IMap#Domain| m@@11) (|ISet#Empty| U@@9))))))
 :pattern ( (|IMap#Domain| m@@11))
)))
(assert (forall ((s T@U) ) (! (let ((T@@3 (SeqTypeInv0 (type s))))
 (=> (= (type s) (SeqType T@@3)) (<= 0 (|Seq#Length| s))))
 :pattern ( (|Seq#Length| s))
)))
(assert (forall ((arg0@@40 T@U) ) (! (= (type (Inv0_TMap arg0@@40)) TyType)
 :pattern ( (Inv0_TMap arg0@@40))
)))
(assert (forall ((t@@0 T@U) (u@@1 T@U) ) (!  (=> (and (= (type t@@0) TyType) (= (type u@@1) TyType)) (= (Inv0_TMap (TMap t@@0 u@@1)) t@@0))
 :pattern ( (TMap t@@0 u@@1))
)))
(assert (forall ((arg0@@41 T@U) ) (! (= (type (Inv1_TMap arg0@@41)) TyType)
 :pattern ( (Inv1_TMap arg0@@41))
)))
(assert (forall ((t@@1 T@U) (u@@2 T@U) ) (!  (=> (and (= (type t@@1) TyType) (= (type u@@2) TyType)) (= (Inv1_TMap (TMap t@@1 u@@2)) u@@2))
 :pattern ( (TMap t@@1 u@@2))
)))
(assert (forall ((t@@2 T@U) (u@@3 T@U) ) (!  (=> (and (= (type t@@2) TyType) (= (type u@@3) TyType)) (= (Tag (TMap t@@2 u@@3)) TagMap))
 :pattern ( (TMap t@@2 u@@3))
)))
(assert (forall ((arg0@@42 T@U) ) (! (= (type (Inv0_TIMap arg0@@42)) TyType)
 :pattern ( (Inv0_TIMap arg0@@42))
)))
(assert (forall ((t@@3 T@U) (u@@4 T@U) ) (!  (=> (and (= (type t@@3) TyType) (= (type u@@4) TyType)) (= (Inv0_TIMap (TIMap t@@3 u@@4)) t@@3))
 :pattern ( (TIMap t@@3 u@@4))
)))
(assert (forall ((arg0@@43 T@U) ) (! (= (type (Inv1_TIMap arg0@@43)) TyType)
 :pattern ( (Inv1_TIMap arg0@@43))
)))
(assert (forall ((t@@4 T@U) (u@@5 T@U) ) (!  (=> (and (= (type t@@4) TyType) (= (type u@@5) TyType)) (= (Inv1_TIMap (TIMap t@@4 u@@5)) u@@5))
 :pattern ( (TIMap t@@4 u@@5))
)))
(assert (forall ((t@@5 T@U) (u@@6 T@U) ) (!  (=> (and (= (type t@@5) TyType) (= (type u@@6) TyType)) (= (Tag (TIMap t@@5 u@@6)) TagIMap))
 :pattern ( (TIMap t@@5 u@@6))
)))
(assert  (and (forall ((arg0@@44 T@U) ) (! (= (type (TSeq arg0@@44)) TyType)
 :pattern ( (TSeq arg0@@44))
)) (forall ((arg0@@45 T@U) (arg1@@20 Int) ) (! (let ((T@@4 (SeqTypeInv0 (type arg0@@45))))
(= (type (|Seq#Index| arg0@@45 arg1@@20)) T@@4))
 :pattern ( (|Seq#Index| arg0@@45 arg1@@20))
))))
(assert (forall ((v@@5 T@U) (t0@@3 T@U) (h@@5 T@U) ) (!  (=> (and (and (= (type v@@5) (SeqType BoxType)) (= (type t0@@3) TyType)) (= (type h@@5) (MapType0Type refType MapType1Type))) (= ($IsAlloc v@@5 (TSeq t0@@3) h@@5) (forall ((i Int) ) (!  (=> (and (<= 0 i) (< i (|Seq#Length| v@@5))) ($IsAllocBox (|Seq#Index| v@@5 i) t0@@3 h@@5))
 :pattern ( (|Seq#Index| v@@5 i))
))))
 :pattern ( ($IsAlloc v@@5 (TSeq t0@@3) h@@5))
)))
(assert (forall ((w Int) ) (! (= (Inv0_TBitvector (TBitvector w)) w)
 :pattern ( (TBitvector w))
)))
(assert (forall ((arg0@@46 T@U) ) (! (= (type (Inv0_TSet arg0@@46)) TyType)
 :pattern ( (Inv0_TSet arg0@@46))
)))
(assert (forall ((t@@6 T@U) ) (!  (=> (= (type t@@6) TyType) (= (Inv0_TSet (TSet t@@6)) t@@6))
 :pattern ( (TSet t@@6))
)))
(assert (forall ((t@@7 T@U) ) (!  (=> (= (type t@@7) TyType) (= (Tag (TSet t@@7)) TagSet))
 :pattern ( (TSet t@@7))
)))
(assert (forall ((arg0@@47 T@U) ) (! (= (type (Inv0_TISet arg0@@47)) TyType)
 :pattern ( (Inv0_TISet arg0@@47))
)))
(assert (forall ((t@@8 T@U) ) (!  (=> (= (type t@@8) TyType) (= (Inv0_TISet (TISet t@@8)) t@@8))
 :pattern ( (TISet t@@8))
)))
(assert (forall ((t@@9 T@U) ) (!  (=> (= (type t@@9) TyType) (= (Tag (TISet t@@9)) TagISet))
 :pattern ( (TISet t@@9))
)))
(assert  (and (forall ((arg0@@48 T@U) ) (! (= (type (TMultiSet arg0@@48)) TyType)
 :pattern ( (TMultiSet arg0@@48))
)) (forall ((arg0@@49 T@U) ) (! (= (type (Inv0_TMultiSet arg0@@49)) TyType)
 :pattern ( (Inv0_TMultiSet arg0@@49))
))))
(assert (forall ((t@@10 T@U) ) (!  (=> (= (type t@@10) TyType) (= (Inv0_TMultiSet (TMultiSet t@@10)) t@@10))
 :pattern ( (TMultiSet t@@10))
)))
(assert (forall ((t@@11 T@U) ) (!  (=> (= (type t@@11) TyType) (= (Tag (TMultiSet t@@11)) TagMultiSet))
 :pattern ( (TMultiSet t@@11))
)))
(assert (forall ((arg0@@50 T@U) ) (! (= (type (Inv0_TSeq arg0@@50)) TyType)
 :pattern ( (Inv0_TSeq arg0@@50))
)))
(assert (forall ((t@@12 T@U) ) (!  (=> (= (type t@@12) TyType) (= (Inv0_TSeq (TSeq t@@12)) t@@12))
 :pattern ( (TSeq t@@12))
)))
(assert (forall ((t@@13 T@U) ) (!  (=> (= (type t@@13) TyType) (= (Tag (TSeq t@@13)) TagSeq))
 :pattern ( (TSeq t@@13))
)))
(assert (forall ((T@@5 T@T) (arg0@@51 T@U) ) (! (= (type ($Unbox T@@5 arg0@@51)) T@@5)
 :pattern ( ($Unbox T@@5 arg0@@51))
)))
(assert (forall ((x@@4 T@U) ) (! (let ((T@@6 (type x@@4)))
(= ($Unbox T@@6 ($Box x@@4)) x@@4))
 :pattern ( ($Box x@@4))
)))
(assert (forall ((o T@U) ) (! (let ((T@@7 (type o)))
 (not (U_2_bool (MapType0Select (|ISet#Empty| T@@7) o))))
 :pattern ( (let ((T@@7 (type o)))
(MapType0Select (|ISet#Empty| T@@7) o)))
)))
(assert (forall ((v@@6 T@U) (t0@@4 T@U) (h@@6 T@U) ) (!  (=> (and (and (= (type v@@6) (MapType0Type BoxType intType)) (= (type t0@@4) TyType)) (= (type h@@6) (MapType0Type refType MapType1Type))) (= ($IsAlloc v@@6 (TMultiSet t0@@4) h@@6) (forall ((bx@@3 T@U) ) (!  (=> (and (= (type bx@@3) BoxType) (< 0 (U_2_int (MapType0Select v@@6 bx@@3)))) ($IsAllocBox bx@@3 t0@@4 h@@6))
 :pattern ( (MapType0Select v@@6 bx@@3))
))))
 :pattern ( ($IsAlloc v@@6 (TMultiSet t0@@4) h@@6))
)))
(assert (forall ((x@@5 Int) ) (! (= ($Box (int_2_U (LitInt x@@5))) (Lit ($Box (int_2_U x@@5))))
 :pattern ( ($Box (int_2_U (LitInt x@@5))))
)))
(assert (forall ((x@@6 T@U) ) (! (= ($Box (Lit x@@6)) (Lit ($Box x@@6)))
 :pattern ( ($Box (Lit x@@6)))
)))
(assert (forall ((s@@0 T@U) ) (! (let ((T@@8 (SeqTypeInv0 (type s@@0))))
 (=> (and (= (type s@@0) (SeqType T@@8)) (= (|Seq#Length| s@@0) 0)) (= s@@0 (|Seq#Empty| T@@8))))
 :pattern ( (|Seq#Length| s@@0))
)))
(assert (forall ((h@@7 T@U) (v@@7 T@U) ) (!  (=> (and (= (type h@@7) (MapType0Type refType MapType1Type)) (= (type v@@7) intType)) ($IsAlloc v@@7 TInt h@@7))
 :pattern ( ($IsAlloc v@@7 TInt h@@7))
)))
(assert (forall ((h@@8 T@U) (v@@8 T@U) ) (!  (=> (and (= (type h@@8) (MapType0Type refType MapType1Type)) (= (type v@@8) realType)) ($IsAlloc v@@8 TReal h@@8))
 :pattern ( ($IsAlloc v@@8 TReal h@@8))
)))
(assert (forall ((h@@9 T@U) (v@@9 T@U) ) (!  (=> (and (= (type h@@9) (MapType0Type refType MapType1Type)) (= (type v@@9) boolType)) ($IsAlloc v@@9 TBool h@@9))
 :pattern ( ($IsAlloc v@@9 TBool h@@9))
)))
(assert (= (Ctor charType) 14))
(assert (forall ((h@@10 T@U) (v@@10 T@U) ) (!  (=> (and (= (type h@@10) (MapType0Type refType MapType1Type)) (= (type v@@10) charType)) ($IsAlloc v@@10 TChar h@@10))
 :pattern ( ($IsAlloc v@@10 TChar h@@10))
)))
(assert (forall ((h@@11 T@U) (v@@11 T@U) ) (!  (=> (and (= (type h@@11) (MapType0Type refType MapType1Type)) (= (type v@@11) BoxType)) ($IsAlloc v@@11 TORDINAL h@@11))
 :pattern ( ($IsAlloc v@@11 TORDINAL h@@11))
)))
(push 1)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun $_Frame@0 () T@U)
(declare-fun null () T@U)
(declare-fun $Heap () T@U)
(declare-fun |##a#0@0| () Int)
(declare-fun |##b#0@0| () Int)
(declare-fun |##a#1@0| () Int)
(declare-fun |##b#1@0| () Int)
(declare-fun |##a#2@0| () Int)
(declare-fun |##b#2@0| () Int)
(declare-fun |##a#3@0| () Int)
(declare-fun |##b#3@0| () Int)
(declare-fun |##a#4@0| () Int)
(declare-fun |##b#4@0| () Int)
(declare-fun |##a#5@0| () Int)
(declare-fun |##b#5@0| () Int)
(declare-fun |##a#6@0| () Int)
(declare-fun |##b#6@0| () Int)
(declare-fun |##a#7@0| () Int)
(declare-fun |##b#7@0| () Int)
(declare-fun |##a#8@0| () Int)
(declare-fun |##b#8@0| () Int)
(declare-fun |##a#9@0| () Int)
(declare-fun |##b#9@0| () Int)
(declare-fun |##a#10@0| () Int)
(declare-fun |##b#10@0| () Int)
(declare-fun |##a#11@0| () Int)
(declare-fun |##b#11@0| () Int)
(declare-fun |##a#12@0| () Int)
(declare-fun |##b#12@0| () Int)
(declare-fun |##a#13@0| () Int)
(declare-fun |##b#13@0| () Int)
(declare-fun $IsGoodHeap (T@U) Bool)
(declare-fun $IsHeapAnchor (T@U) Bool)
(assert  (and (and (= (type $_Frame@0) (MapType2Type refType boolType)) (= (type null) refType)) (= (type $Heap) (MapType0Type refType MapType1Type))))
(set-option :timeout 0)
(set-option :rlimit 0)
(assert (not
 (=> (= (ControlFlow 0 0) 16) (let ((anon0_correct  (=> (= $_Frame@0 (|lambda#0| null $Heap alloc false)) (=> (and (= |##a#0@0| (LitInt 2)) ($IsAlloc (int_2_U |##a#0@0|) TInt $Heap)) (=> (and (and (= |##b#0@0| (LitInt 11)) ($IsAlloc (int_2_U |##b#0@0|) TInt $Heap)) (and (|_module.__default.add#canCall| (LitInt 2) (LitInt 11)) (|_module.__default.add#canCall| (LitInt 2) (LitInt 11)))) (and (=> (= (ControlFlow 0 2) (- 0 15)) (= (LitInt (_module.__default.add (LitInt 2) (LitInt 11))) (LitInt 13))) (=> (= (LitInt (_module.__default.add (LitInt 2) (LitInt 11))) (LitInt 13)) (=> (and (= |##a#1@0| (LitInt 10)) ($IsAlloc (int_2_U |##a#1@0|) TInt $Heap)) (=> (and (and (= |##b#1@0| (LitInt 4)) ($IsAlloc (int_2_U |##b#1@0|) TInt $Heap)) (and (|_module.__default.add#canCall| (LitInt 10) (LitInt 4)) (|_module.__default.add#canCall| (LitInt 10) (LitInt 4)))) (and (=> (= (ControlFlow 0 2) (- 0 14)) (= (LitInt (_module.__default.add (LitInt 10) (LitInt 4))) (LitInt 14))) (=> (= (LitInt (_module.__default.add (LitInt 10) (LitInt 4))) (LitInt 14)) (=> (and (= |##a#2@0| (LitInt 11)) ($IsAlloc (int_2_U |##a#2@0|) TInt $Heap)) (=> (and (and (= |##b#2@0| (LitInt 20)) ($IsAlloc (int_2_U |##b#2@0|) TInt $Heap)) (and (|_module.__default.add#canCall| (LitInt 11) (LitInt 20)) (|_module.__default.add#canCall| (LitInt 11) (LitInt 20)))) (and (=> (= (ControlFlow 0 2) (- 0 13)) (= (LitInt (_module.__default.add (LitInt 11) (LitInt 20))) (LitInt 31))) (=> (= (LitInt (_module.__default.add (LitInt 11) (LitInt 20))) (LitInt 31)) (=> (and (= |##a#3@0| (LitInt 15)) ($IsAlloc (int_2_U |##a#3@0|) TInt $Heap)) (=> (and (and (= |##b#3@0| (LitInt 20)) ($IsAlloc (int_2_U |##b#3@0|) TInt $Heap)) (and (|_module.__default.add#canCall| (LitInt 15) (LitInt 20)) (|_module.__default.add#canCall| (LitInt 15) (LitInt 20)))) (and (=> (= (ControlFlow 0 2) (- 0 12)) (= (LitInt (_module.__default.add (LitInt 15) (LitInt 20))) (LitInt 35))) (=> (= (LitInt (_module.__default.add (LitInt 15) (LitInt 20))) (LitInt 35)) (=> (and (= |##a#4@0| (LitInt 5)) ($IsAlloc (int_2_U |##a#4@0|) TInt $Heap)) (=> (and (and (= |##b#4@0| (LitInt 16)) ($IsAlloc (int_2_U |##b#4@0|) TInt $Heap)) (and (|_module.__default.add#canCall| (LitInt 5) (LitInt 16)) (|_module.__default.add#canCall| (LitInt 5) (LitInt 16)))) (and (=> (= (ControlFlow 0 2) (- 0 11)) (= (LitInt (_module.__default.add (LitInt 5) (LitInt 16))) (LitInt 21))) (=> (= (LitInt (_module.__default.add (LitInt 5) (LitInt 16))) (LitInt 21)) (=> (and (= |##a#5@0| (LitInt 18)) ($IsAlloc (int_2_U |##a#5@0|) TInt $Heap)) (=> (and (and (= |##b#5@0| (LitInt 9)) ($IsAlloc (int_2_U |##b#5@0|) TInt $Heap)) (and (|_module.__default.add#canCall| (LitInt 18) (LitInt 9)) (|_module.__default.add#canCall| (LitInt 18) (LitInt 9)))) (and (=> (= (ControlFlow 0 2) (- 0 10)) (= (LitInt (_module.__default.add (LitInt 18) (LitInt 9))) (LitInt 27))) (=> (= (LitInt (_module.__default.add (LitInt 18) (LitInt 9))) (LitInt 27)) (=> (and (= |##a#6@0| (LitInt 0)) ($IsAlloc (int_2_U |##a#6@0|) TInt $Heap)) (=> (and (and (= |##b#6@0| (LitInt 16)) ($IsAlloc (int_2_U |##b#6@0|) TInt $Heap)) (and (|_module.__default.add#canCall| (LitInt 0) (LitInt 16)) (|_module.__default.add#canCall| (LitInt 0) (LitInt 16)))) (and (=> (= (ControlFlow 0 2) (- 0 9)) (= (LitInt (_module.__default.add (LitInt 0) (LitInt 16))) (LitInt 16))) (=> (= (LitInt (_module.__default.add (LitInt 0) (LitInt 16))) (LitInt 16)) (=> (and (= |##a#7@0| (LitInt 11)) ($IsAlloc (int_2_U |##a#7@0|) TInt $Heap)) (=> (and (and (= |##b#7@0| (LitInt 19)) ($IsAlloc (int_2_U |##b#7@0|) TInt $Heap)) (and (|_module.__default.add#canCall| (LitInt 11) (LitInt 19)) (|_module.__default.add#canCall| (LitInt 11) (LitInt 19)))) (and (=> (= (ControlFlow 0 2) (- 0 8)) (= (LitInt (_module.__default.add (LitInt 11) (LitInt 19))) (LitInt 30))) (=> (= (LitInt (_module.__default.add (LitInt 11) (LitInt 19))) (LitInt 30)) (=> (and (= |##a#8@0| (LitInt 12)) ($IsAlloc (int_2_U |##a#8@0|) TInt $Heap)) (=> (and (and (= |##b#8@0| (LitInt 3)) ($IsAlloc (int_2_U |##b#8@0|) TInt $Heap)) (and (|_module.__default.add#canCall| (LitInt 12) (LitInt 3)) (|_module.__default.add#canCall| (LitInt 12) (LitInt 3)))) (and (=> (= (ControlFlow 0 2) (- 0 7)) (= (LitInt (_module.__default.add (LitInt 12) (LitInt 3))) (LitInt 15))) (=> (= (LitInt (_module.__default.add (LitInt 12) (LitInt 3))) (LitInt 15)) (=> (and (= |##a#9@0| (LitInt 9)) ($IsAlloc (int_2_U |##a#9@0|) TInt $Heap)) (=> (and (and (= |##b#9@0| (LitInt 19)) ($IsAlloc (int_2_U |##b#9@0|) TInt $Heap)) (and (|_module.__default.add#canCall| (LitInt 9) (LitInt 19)) (|_module.__default.add#canCall| (LitInt 9) (LitInt 19)))) (and (=> (= (ControlFlow 0 2) (- 0 6)) (= (LitInt (_module.__default.add (LitInt 9) (LitInt 19))) (LitInt 28))) (=> (= (LitInt (_module.__default.add (LitInt 9) (LitInt 19))) (LitInt 28)) (=> (and (= |##a#10@0| (LitInt 1)) ($IsAlloc (int_2_U |##a#10@0|) TInt $Heap)) (=> (and (and (= |##b#10@0| (LitInt 9)) ($IsAlloc (int_2_U |##b#10@0|) TInt $Heap)) (and (|_module.__default.add#canCall| (LitInt 1) (LitInt 9)) (|_module.__default.add#canCall| (LitInt 1) (LitInt 9)))) (and (=> (= (ControlFlow 0 2) (- 0 5)) (= (LitInt (_module.__default.add (LitInt 1) (LitInt 9))) (LitInt 10))) (=> (= (LitInt (_module.__default.add (LitInt 1) (LitInt 9))) (LitInt 10)) (=> (and (= |##a#11@0| (LitInt 7)) ($IsAlloc (int_2_U |##a#11@0|) TInt $Heap)) (=> (and (and (= |##b#11@0| (LitInt 5)) ($IsAlloc (int_2_U |##b#11@0|) TInt $Heap)) (and (|_module.__default.add#canCall| (LitInt 7) (LitInt 5)) (|_module.__default.add#canCall| (LitInt 7) (LitInt 5)))) (and (=> (= (ControlFlow 0 2) (- 0 4)) (= (LitInt (_module.__default.add (LitInt 7) (LitInt 5))) (LitInt 12))) (=> (= (LitInt (_module.__default.add (LitInt 7) (LitInt 5))) (LitInt 12)) (=> (and (= |##a#12@0| (LitInt 10)) ($IsAlloc (int_2_U |##a#12@0|) TInt $Heap)) (=> (and (and (= |##b#12@0| (LitInt 17)) ($IsAlloc (int_2_U |##b#12@0|) TInt $Heap)) (and (|_module.__default.add#canCall| (LitInt 10) (LitInt 17)) (|_module.__default.add#canCall| (LitInt 10) (LitInt 17)))) (and (=> (= (ControlFlow 0 2) (- 0 3)) (= (LitInt (_module.__default.add (LitInt 10) (LitInt 17))) (LitInt 27))) (=> (= (LitInt (_module.__default.add (LitInt 10) (LitInt 17))) (LitInt 27)) (=> (= |##a#13@0| (LitInt 10)) (=> (and ($IsAlloc (int_2_U |##a#13@0|) TInt $Heap) (= |##b#13@0| (LitInt 0))) (=> (and (and ($IsAlloc (int_2_U |##b#13@0|) TInt $Heap) (|_module.__default.add#canCall| (LitInt 10) (LitInt 0))) (and (|_module.__default.add#canCall| (LitInt 10) (LitInt 0)) (= (ControlFlow 0 2) (- 0 1)))) (= (LitInt (_module.__default.add (LitInt 10) (LitInt 0))) (LitInt 10))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and ($IsGoodHeap $Heap) ($IsHeapAnchor $Heap)) (and (= 1 $FunctionContextHeight) (= (ControlFlow 0 16) 2))) anon0_correct)))
PreconditionGeneratedEntry_correct)))
))
(check-sat)
(pop 1)
; Valid
(get-info :rlimit)
